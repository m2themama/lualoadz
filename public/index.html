<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LuaLoadz</title>
    <!-- Favicon links -->
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
    <canvas id="spark-canvas"></canvas>
    <img
      class="ps5-bg"
      src="data:image/svg+xml;utf8,<svg width='1600' height='400' viewBox='0 0 1600 400' fill='none' xmlns='http://www.w3.org/2000/svg'><g opacity='0.8'><ellipse cx='1200' cy='340' rx='220' ry='50' fill='%230050d8'/><rect x='1100' y='120' width='220' height='200' rx='70' fill='%23bfc9db' stroke='%230050d8' stroke-width='12'/><rect x='1160' y='170' width='100' height='120' rx='36' fill='%23181a20' stroke='%230050d8' stroke-width='6'/><ellipse cx='1300' cy='340' rx='60' ry='18' fill='%23181a20'/><ellipse cx='400' cy='360' rx='160' ry='36' fill='%230050d8'/><rect x='220' y='240' width='320' height='100' rx='50' fill='%23bfc9db' stroke='%230050d8' stroke-width='12'/><rect x='270' y='270' width='220' height='40' rx='20' fill='%23181a20' stroke='%230050d8' stroke-width='6'/></g><g opacity='0.5'><ellipse cx='800' cy='390' rx='600' ry='30' fill='%230050d8'/></g><g opacity='0.18'><path d='M0 380 Q800 320 1600 380' stroke='%237cb8ff' stroke-width='8' fill='none'/></g></svg>"
      alt="PS5 Console and Controller"
    />
    <div class="container">
      <div class="header">
        <h1>
          <img src="/favicon.svg" alt="LuaLoadz Logo" class="logo" />
          LuaLoadz
        </h1>
        <p>
          Use this tool to send files to your PS5 running the
          <a href="https://github.com/shahrilnet/remote_lua_loader"
            >remote-lua-loader</a
          >. First, find your PS5 on the network or enter it's IP address and
          port, then select the type of file you want to send.
        </p>
      </div>

      <!-- Network Scan Section -->
      <div class="section" id="network-scan-section">
        <h2>Find Your PS5</h2>
        <div class="form-group">
          <div class="scan-controls">
            <button id="scanNetwork" class="btn btn-primary">
              Scan Network
            </button>
          </div>
          <div id="scanStatus" class="scan-status"></div>
          <div id="ps5Devices" class="ps5-devices" style="display: none">
            <select id="availableIPs" class="form-control">
              <option value="">Select a PS5</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label for="ipAddress">IP Address:</label>
          <input type="text" id="ipAddress" name="ipAddress" required />
        </div>
        <div class="form-group">
          <label for="port">Port:</label>
          <input type="number" id="port" name="port" required />
        </div>
      </div>

      <!-- Main Content Tabs -->
      <div class="main-tabs">
        <div class="main-tab active" data-tab="lua-tab">Lua Files (9026)</div>
        <div class="main-tab" data-tab="elf-tab">ELF/BIN Files (9021)</div>
        <div class="main-tab" data-tab="pkg-tab">PKG Files (12800)</div>
      </div>

      <!-- Lua Tab Content -->
      <div id="lua-tab" class="main-tab-content active">
        <form id="luaForm" enctype="multipart/form-data">
          <div class="file-selection">
            <h3>Lua Files</h3>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="umtx.lua" />
                <span>umtx.lua</span>
                <span class="file-info">(42KB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="elf_loader.lua" />
                <span>elf_loader.lua</span>
                <span class="file-info">(9.1KB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="ftp_server.lua" />
                <span>ftp_server.lua</span>
                <span class="file-info">(29KB)</span>
              </label>
            </div>
            <h3 style="text-align: center">or</h3>
            <div class="file-upload-container" id="lua-upload-container">
              <div class="file-upload-area" id="lua-upload-area">
                <input
                  type="file"
                  id="luaFile"
                  name="luaFile"
                  accept=".lua"
                  class="file-input"
                />
                <div class="upload-placeholder">
                  <svg class="upload-icon" viewBox="0 0 24 24">
                    <path
                      d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
                    />
                  </svg>

                  <p class="upload-text">Drag & drop your LUA file here</p>
                  <p class="upload-subtext">or click to browse</p>
                </div>
                <div class="file-info" id="luaFileInfo" style="display: none">
                  <span id="luaFileName"></span><br />
                  <span id="luaFileSize"></span> bytes
                </div>
              </div>
            </div>
          </div>
          <button type="submit" id="sendLuaButton">Send Lua File</button>
        </form>
      </div>

      <!-- ELF/BIN Tab Content -->
      <div id="elf-tab" class="main-tab-content">
        <form id="elfForm" enctype="multipart/form-data">
          <div class="file-selection">
            <h3>ELF/BIN Files</h3>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="etaHEN.bin" />
                <span>etaHEN.bin</span>
                <span class="file-info">(2.2MB)</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="websrv.elf" />
                <span>websrv.elf</span>
                <span class="file-info">(689KB) - Web Server</span>
              </label>
            </div>
            <div class="file-option">
              <label>
                <input type="radio" name="fileType" value="ftps5.elf" />
                <span>ftps5.elf</span>
                <span class="file-info">(26KB) - FTP Server</span>
              </label>
            </div>
            <h3 style="text-align: center">or</h3>
            <div class="file-upload-container" id="elf-upload-container">
              <div class="file-upload-area" id="elf-upload-area">
                <input
                  type="file"
                  id="elfFile"
                  name="elfFile"
                  accept=".elf,.bin"
                  class="file-input"
                />
                <div class="upload-placeholder">
                  <svg class="upload-icon" viewBox="0 0 24 24">
                    <path
                      d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
                    />
                  </svg>
                  <p class="upload-text">Drag & drop your ELF/BIN file here</p>
                  <p class="upload-subtext">or click to browse</p>
                </div>
                <div class="file-info" id="elfFileInfo" style="display: none">
                  <span id="elfFileName"></span><br />
                  <span id="elfFileSize"></span> bytes
                </div>
              </div>
            </div>
          </div>
          <button type="submit" id="sendElfButton">Send ELF/BIN File</button>
        </form>
      </div>

      <!-- PKG Tab Content -->
      <div id="pkg-tab" class="main-tab-content">
        <form id="pkgForm" enctype="multipart/form-data">
          <div class="form-group">
            <label for="pkg-file">Upload PKG File:</label>
            <div class="file-upload-container" id="pkg-upload-container">
              <div class="file-upload-area" id="pkg-upload-area">
                <input
                  type="file"
                  id="pkg-file"
                  name="file"
                  accept=".pkg"
                  class="file-input"
                />
                <div class="upload-placeholder">
                  <svg class="upload-icon" viewBox="0 0 24 24">
                    <path
                      d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
                    />
                  </svg>
                  <p class="upload-text">Drag & drop your PKG file here</p>
                  <p class="upload-subtext">or click to browse</p>
                </div>
                <div class="file-info" id="pkg-file-info" style="display: none">
                  <p class="file-name" id="pkg-file-name"></p>
                  <p class="file-size" id="pkg-file-size"></p>
                </div>
              </div>
            </div>
          </div>
          <div class="or-divider">
            <h3 style="text-align: center">or</h3>
          </div>
          <div class="form-group">
            <label for="pkg-url">Enter your PKG URL:</label>
            <input
              type="text"
              id="pkg-url"
              name="url"
              placeholder="http://example.com/game.pkg"
              class="form-control"
            />
          </div>
          <div class="button-group" style="display: flex; gap: 10px">
            <button type="submit" id="install-pkg">Install PKG</button>
            <button type="button" id="clear-tmp" class="btn-secondary">
              Clear Temporary Files
            </button>
          </div>
          <div
            class="progress-container"
            id="pkg-progress"
            style="display: none"
          >
            <div class="progress">
              <div
                class="progress-bar"
                id="pkg-progress-bar"
                style="width: 0%"
              ></div>
            </div>
            <div class="progress-info" id="pkg-progress-info">0%</div>
          </div>
          <div id="pkg-result" class="result"></div>
        </form>
      </div>

      <div id="status" style="display: none"></div>

      <!-- Log Tabs -->
      <div class="log-tabs">
        <div class="log-tab active" data-tab="user-log">Details</div>
        <div class="log-tab" data-tab="technical-log">Log</div>
      </div>

      <div id="user-log" class="log-tab-content active">
        <div class="log-container" id="log"></div>
      </div>

      <div id="technical-log" class="log-tab-content">
        <div class="technical-log" id="techLog"></div>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const luaForm = document.getElementById("luaForm");
        const ipAddressInput = document.getElementById("ipAddress");
        const portInput = document.getElementById("port");
        const fileInput = document.getElementById("luaFile");
        const fileInfoDiv = document.getElementById("fileInfo");
        const fileNameSpan = document.getElementById("fileName");
        const fileSizeSpan = document.getElementById("fileSize");
        const statusDiv = document.getElementById("status");
        const logDiv = document.getElementById("log");
        const techLogDiv = document.getElementById("techLog");
        const tabs = document.querySelectorAll(".tab");
        const tabContents = document.querySelectorAll(".tab-content");

        // SSE connection
        let eventSource = null;

        // Function to connect to SSE
        function connectSSE() {
          if (eventSource) {
            eventSource.close();
          }

          eventSource = new EventSource("/events");

          eventSource.onmessage = function (event) {
            const data = JSON.parse(event.data);

            switch (data.type) {
              case "status":
                log(data.message, "info");
                techLog(data.message, "info");
                break;

              case "error":
                log(data.message, "error");
                techLog(data.message, "error");
                showStatus(data.message, "error");
                break;

              case "success":
                log(data.message, "success");
                techLog(data.message, "success");
                showStatus(data.message, "success");
                break;

              case "data":
                // For user-friendly logs, show the actual message content
                if (data.message && data.message.trim()) {
                  log(data.message, "info");
                }

                // For technical logs, show both hex and ASCII
                const hexData = data.hex.match(/.{1,2}/g).join(" ");
                const truncatedHex =
                  hexData.length > 100
                    ? hexData.substring(0, 100) + "..."
                    : hexData;

                const strData = data.message.replace(/[^\x20-\x7E]/g, ".");
                const truncatedStr =
                  strData.length > 100
                    ? strData.substring(0, 100) + "..."
                    : strData;

                techLog(`RECEIVED [HEX]: ${truncatedHex}`, "receive");
                techLog(`RECEIVED [ASCII]: ${truncatedStr}`, "receive");
                break;
            }
          };

          eventSource.onerror = function (err) {
            console.error("SSE Error:", err);
            eventSource.close();
          };
        }

        // Main tab switching
        const mainTabs = document.querySelectorAll(".main-tab");
        const mainTabContents = document.querySelectorAll(".main-tab-content");

        mainTabs.forEach((tab) => {
          tab.addEventListener("click", function () {
            // Remove active class from all main tabs and contents
            mainTabs.forEach((t) => t.classList.remove("active"));
            mainTabContents.forEach((c) => c.classList.remove("active"));

            // Add active class to clicked tab and corresponding content
            this.classList.add("active");
            const tabId = this.getAttribute("data-tab");
            document.getElementById(tabId).classList.add("active");

            // Update port based on selected tab
            const portInput = document.getElementById("port");
            switch (tabId) {
              case "lua-tab":
                portInput.value = "9026";
                break;
              case "elf-tab":
                portInput.value = "9021";
                break;
              case "pkg-tab":
                portInput.value = "12800";
                break;
            }
          });
        });

        // Log tab switching
        const logTabs = document.querySelectorAll(".log-tab");
        const logTabContents = document.querySelectorAll(".log-tab-content");

        logTabs.forEach((tab) => {
          tab.addEventListener("click", function () {
            // Remove active class from all log tabs and contents
            logTabs.forEach((t) => t.classList.remove("active"));
            logTabContents.forEach((c) => c.classList.remove("active"));

            // Add active class to clicked tab and corresponding content
            this.classList.add("active");
            const tabId = this.getAttribute("data-tab");
            document.getElementById(tabId).classList.add("active");
          });
        });

        // Update port when PS5 is selected from network scan
        document
          .getElementById("availableIPs")
          .addEventListener("change", function (e) {
            const selectedIP = e.target.value;
            if (selectedIP) {
              document.getElementById("ipAddress").value = selectedIP;
              // Keep the current port based on the active tab
              const activeTab = document.querySelector(".main-tab.active");
              const portInput = document.getElementById("port");
              switch (activeTab.getAttribute("data-tab")) {
                case "lua-tab":
                  portInput.value = "9026";
                  break;
                case "elf-tab":
                  portInput.value = "9021";
                  break;
                case "pkg-tab":
                  portInput.value = "12800";
                  break;
              }
            }
          });

        // File info display
        fileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            fileNameSpan.textContent = file.name;
            fileSizeSpan.textContent = file.size;
            fileInfoDiv.style.display = "block";
          } else {
            fileInfoDiv.style.display = "none";
          }
        });

        // File selection handling
        const manualLuaInput = document.getElementById("manualLuaInput");
        const manualElfInput = document.getElementById("manualElfInput");
        // The following variables are already declared and will be reused:
        // luaFileInput, elfFileInput, luaFileInfo, elfFileInfo, luaFileName, luaFileSize, elfFileName, elfFileSize

        // Function to clear all file inputs
        function clearFileInputs() {
          luaFileInput.value = "";
          elfFileInput.value = "";
          luaFileInfo.style.display = "none";
          elfFileInfo.style.display = "none";
        }

        // Function to clear all radio selections
        function clearRadioSelections() {
          document
            .querySelectorAll('input[name="fileType"]')
            .forEach((radio) => {
              radio.checked = false;
            });
        }

        // Function to clear all form selections
        function clearFormSelections() {
          clearFileInputs();
          clearRadioSelections();
          document.getElementById("pkg-file").value = "";
          document.getElementById("pkg-url").value = "";
          document.getElementById("pkg-progress").style.display = "none";
          document.getElementById("pkg-progress-bar").style.width = "0%";
          document.getElementById("pkg-progress-info").textContent = "0%";
        }

        // Handle radio button changes
        document.querySelectorAll('input[name="fileType"]').forEach((radio) => {
          radio.addEventListener("change", function () {
            // Clear any manual file selections
            clearFileInputs();

            // Hide all manual inputs
            manualLuaInput.classList.remove("active");
            manualElfInput.classList.remove("active");

            // Show appropriate manual input
            if (this.value === "manual_lua") {
              manualLuaInput.classList.add("active");
            } else if (this.value === "manual_elf") {
              manualElfInput.classList.add("active");
            }
          });
        });

        // Handle manual file selection
        luaFileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            if (!file.name.endsWith(".lua")) {
              showStatus("Please select a .lua file", "error");
              this.value = "";
              return;
            }
            // Clear any radio selections when manual file is selected
            clearRadioSelections();
            luaFileName.textContent = file.name;
            luaFileSize.textContent = file.size;
            luaFileInfo.style.display = "block";
          } else {
            luaFileInfo.style.display = "none";
          }
        });

        elfFileInput.addEventListener("change", function () {
          const file = this.files[0];
          if (file) {
            if (!file.name.endsWith(".elf") && !file.name.endsWith(".bin")) {
              showStatus("Please select a .elf or .bin file", "error");
              this.value = "";
              return;
            }
            // Clear any radio selections when manual file is selected
            clearRadioSelections();
            elfFileName.textContent = file.name;
            elfFileSize.textContent = file.size;
            elfFileInfo.style.display = "block";
          } else {
            elfFileInfo.style.display = "none";
          }
        });

        // Log function for user-friendly logs
        function log(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");

          // Special handling for exploit output
          if (message.includes("Response from device: umtx exploit")) {
            const exploitOutput = document.createElement("pre");
            exploitOutput.className = "exploit-output";

            // Split the message into lines and format each line
            const lines = message.split("\n");
            lines.forEach((line) => {
              const lineDiv = document.createElement("div");

              if (
                line.includes("exploit config:") ||
                line.includes("thread config:")
              ) {
                lineDiv.className = "config";
              } else if (
                line.includes("successfully") ||
                line.includes("achieved") ||
                line.includes("done!")
              ) {
                lineDiv.className = "success";
              } else if (
                line.includes("== attempt #") ||
                line.includes("race started")
              ) {
                lineDiv.className = "attempt";
              } else if (line.includes("failed") || line.includes("retry")) {
                lineDiv.className = "error";
              }

              lineDiv.textContent = line;
              exploitOutput.appendChild(lineDiv);
            });

            logEntry.appendChild(exploitOutput);
          } else if (message.includes("Received data from device:")) {
            // Extract the actual message content
            const content = message
              .replace("Received data from device:", "")
              .trim();
            if (content) {
              logEntry.className = "device-message";
              logEntry.textContent = `[${timestamp}] ${content}`;
            } else {
              return; // Skip empty messages
            }
          } else {
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
          }

          logDiv.appendChild(logEntry);
          logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Log function for technical logs
        function techLog(message, type = "info") {
          const timestamp = new Date().toLocaleTimeString();
          const logEntry = document.createElement("div");

          // Special handling for exploit output
          if (
            message.includes("exploit config:") ||
            message.includes("thread config:") ||
            message.includes("== attempt #") ||
            message.includes("we root now?") ||
            message.includes("we escaped now?") ||
            message.includes("debug menu enabled") ||
            message.includes("exploit state is saved")
          ) {
            type = "exploit";
          } else if (
            message.includes("successfully") ||
            message.includes("achieved") ||
            message.includes("done!")
          ) {
            type = "success";
          } else if (
            message.includes("max_attempt") ||
            message.includes("num_spray_fds") ||
            message.includes("num_kprim_threads") ||
            message.includes("max_race_attempt") ||
            message.includes("core") ||
            message.includes("prio")
          ) {
            type = "config";
          }

          logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> <span class="${type}">${message}</span>`;
          techLogDiv.appendChild(logEntry);
          techLogDiv.scrollTop = techLogDiv.scrollHeight;
        }

        // Show status message
        function showStatus(message, type) {
          statusDiv.textContent = message;
          statusDiv.className = type;
          statusDiv.style.display = "block";
          setTimeout(() => {
            statusDiv.style.display = "none";
          }, 5000);
        }

        // Handle form submission
        luaForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const selectedFile = document.querySelector(
            'input[name="fileType"]:checked'
          );
          const hasManualLuaFile = luaFileInput.files.length > 0;
          const hasManualElfFile = elfFileInput.files.length > 0;

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Validate file selection
          if (!selectedFile && !hasManualLuaFile && !hasManualElfFile) {
            showStatus("Please select a file to send", "error");
            return;
          }

          // Ensure only one selection method is used
          if (
            (selectedFile && (hasManualLuaFile || hasManualElfFile)) ||
            (hasManualLuaFile && hasManualElfFile)
          ) {
            showStatus("Please select only one file", "error");
            return;
          }

          let fileName;
          let fileData;

          if (selectedFile) {
            // Using predefined file
            fileName = selectedFile.value;
          } else if (hasManualLuaFile) {
            // Using manual Lua file
            const file = luaFileInput.files[0];
            fileName = file.name;
            fileData = file;
          } else if (hasManualElfFile) {
            // Using manual ELF file
            const file = elfFileInput.files[0];
            fileName = file.name;
            fileData = file;
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send "${fileName}" to ${ipAddress}:${port}...`);
          techLog(
            `EXECUTE: Sending file "${fileName}" to ${ipAddress}:${port}`,
            "info"
          );

          // Create FormData object and add form fields
          const formData = new FormData();
          if (fileData) {
            formData.append("file", fileData);
          } else {
            formData.append("fileName", fileName);
          }
          formData.append("ipAddress", ipAddress);
          formData.append("port", port);

          try {
            // Send the file using FormData
            techLog(`Request: POST /send-lua (multipart/form-data)`, "info");
            const response = await fetch("/send-lua", {
              method: "POST",
              body: formData,
            });

            const responseText = await response.text();
            techLog(`Response received (${responseText.length} bytes)`, "info");

            let result;
            try {
              // Try to parse as JSON
              result = JSON.parse(responseText);

              // Display technical logs if available
              if (result.logs && Array.isArray(result.logs)) {
                result.logs.forEach((logMsg) => {
                  if (logMsg.includes("SENDING")) {
                    techLog(logMsg, "send");
                  } else if (logMsg.includes("RECEIVED")) {
                    techLog(logMsg, "receive");
                  } else if (
                    logMsg.includes("Error") ||
                    logMsg.includes("error")
                  ) {
                    techLog(logMsg, "error");
                  } else {
                    techLog(logMsg, "info");
                  }
                });
              }
            } catch (parseError) {
              // If parsing fails, treat as plain text error
              techLog(`Error parsing response: ${parseError.message}`, "error");
              techLog(`Raw response: ${responseText}`, "info");
              throw new Error(responseText || "Server error");
            }

            if (result.success) {
              showStatus("File sent successfully!", "success");
              log(`✅ Successfully sent "${fileName}" to ${ipAddress}:${port}`);

              if (result.response) {
                log(`Response from device: ${result.response}`);
                techLog(`Device response: ${result.response}`, "receive");
              }

              // Clear form selections after successful submission
              clearFormSelections();
            } else {
              showStatus(`Error: ${result.error}`, "error");
              log(`❌ Error sending file: ${result.error}`, "error");
              techLog(`Error: ${result.error}`, "error");
            }
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle ELF form submission
        const elfForm = document.getElementById("elfForm");
        elfForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const selectedFile = document.querySelector(
            'input[name="fileType"]:checked'
          );
          const hasManualElfFile = elfFileInput.files.length > 0;

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Validate file selection
          if (!selectedFile && !hasManualElfFile) {
            showStatus("Please select a file to send", "error");
            return;
          }

          let fileName;
          let fileData;

          if (selectedFile) {
            // Using predefined file
            fileName = selectedFile.value;
          } else if (hasManualElfFile) {
            // Using manual ELF file
            const file = elfFileInput.files[0];
            fileName = file.name;
            fileData = file;
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send "${fileName}" to ${ipAddress}:${port}...`);
          techLog(
            `EXECUTE: Sending file "${fileName}" to ${ipAddress}:${port}`,
            "info"
          );

          // Create FormData object and add form fields
          const formData = new FormData();
          if (fileData) {
            formData.append("file", fileData);
          } else {
            formData.append("fileName", fileName);
          }
          formData.append("ipAddress", ipAddress);
          formData.append("port", port);

          try {
            // Send the file using FormData
            techLog(`Request: POST /send-elf (multipart/form-data)`, "info");
            const response = await fetch("/send-elf", {
              method: "POST",
              body: formData,
            });

            const responseText = await response.text();
            techLog(`Response received (${responseText.length} bytes)`, "info");

            let result;
            try {
              // Try to parse as JSON
              result = JSON.parse(responseText);

              // Display technical logs if available
              if (result.logs && Array.isArray(result.logs)) {
                result.logs.forEach((logMsg) => {
                  if (logMsg.includes("SENDING")) {
                    techLog(logMsg, "send");
                  } else if (logMsg.includes("RECEIVED")) {
                    techLog(logMsg, "receive");
                  } else if (
                    logMsg.includes("Error") ||
                    logMsg.includes("error")
                  ) {
                    techLog(logMsg, "error");
                  } else {
                    techLog(logMsg, "info");
                  }
                });
              }
            } catch (parseError) {
              // If parsing fails, treat as plain text error
              techLog(`Error parsing response: ${parseError.message}`, "error");
              techLog(`Raw response: ${responseText}`, "info");
              throw new Error(responseText || "Server error");
            }

            if (result.success) {
              showStatus("File sent successfully!", "success");
              log(`✅ Successfully sent "${fileName}" to ${ipAddress}:${port}`);

              if (result.response) {
                log(`Response from device: ${result.response}`);
                techLog(`Device response: ${result.response}`, "receive");
              }

              // Clear form selections after successful submission
              clearFormSelections();
            } else {
              showStatus(`Error: ${result.error}`, "error");
              log(`❌ Error sending file: ${result.error}`, "error");
              techLog(`Error: ${result.error}`, "error");
            }
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle PKG file upload
        const pkgUploadArea = document.getElementById("pkg-upload-area");
        const pkgFileInput = document.getElementById("pkg-file");
        const pkgFileInfo = document.getElementById("pkg-file-info");
        const pkgFileName = document.getElementById("pkg-file-name");
        const pkgFileSize = document.getElementById("pkg-file-size");

        // Prevent default drag behaviors
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          pkgUploadArea.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });

        // Highlight drop zone when item is dragged over it
        ["dragenter", "dragover"].forEach((eventName) => {
          pkgUploadArea.addEventListener(eventName, highlight, false);
        });

        ["dragleave", "drop"].forEach((eventName) => {
          pkgUploadArea.addEventListener(eventName, unhighlight, false);
        });

        // Handle dropped files
        pkgUploadArea.addEventListener("drop", handleDrop, false);

        // Handle click to upload
        pkgUploadArea.addEventListener("click", () => {
          pkgFileInput.click();
        });

        // Handle file selection
        pkgFileInput.addEventListener("change", handleFileSelect);

        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }

        function highlight(e) {
          pkgUploadArea.classList.add("highlight");
        }

        function unhighlight(e) {
          pkgUploadArea.classList.remove("highlight");
        }

        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;
          handleFiles(files);
        }

        function handleFileSelect(e) {
          const files = e.target.files;
          handleFiles(files);
        }

        function handleFiles(files) {
          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith(".pkg")) {
              // Set the file input's files property using a DataTransfer
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(file);
              pkgFileInput.files = dataTransfer.files;

              pkgFileName.textContent = file.name;
              pkgFileSize.textContent = formatFileSize(file.size);
              pkgFileInfo.style.display = "block";
              pkgUploadArea.classList.add("has-file");
            } else {
              showStatus("Please select a .pkg file", "error");
              pkgFileInput.value = "";
            }
          }
        }

        function formatFileSize(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        // Handle PKG form submission
        const pkgForm = document.getElementById("pkgForm");
        pkgForm.addEventListener("submit", async function (e) {
          e.preventDefault(); // Prevent default form submission

          const ipAddress = ipAddressInput.value.trim();
          const port = parseInt(portInput.value.trim(), 10);
          const fileInput = document.getElementById("pkg-file");
          const urlInput = document.getElementById("pkg-url");
          const progressContainer = document.getElementById("pkg-progress");
          const progressBar = document.getElementById("pkg-progress-bar");
          const progressInfo = document.getElementById("pkg-progress-info");
          const resultDiv = document.getElementById("pkg-result");

          // Validate form inputs
          if (!ipAddress) {
            showStatus("Please enter an IP address", "error");
            return;
          }

          if (isNaN(port) || port < 0 || port > 65535) {
            showStatus("Please enter a valid port number (0-65535)", "error");
            return;
          }

          // Check if either file or URL is provided
          if (fileInput.files.length === 0 && urlInput.value.trim() === "") {
            resultDiv.innerHTML =
              '<div class="error-box"><h3 class="error">Validation Error</h3>' +
              '<p class="error">Please either select a PKG file to upload or enter a URL.</p></div>';
            return;
          }

          // Create FormData object
          const formData = new FormData();
          if (fileInput.files.length > 0) {
            formData.append("file", fileInput.files[0]);
          } else {
            formData.append("url", urlInput.value.trim());
          }
          formData.append("ipAddress", ipAddress);

          // Show progress bar for file uploads
          if (fileInput.files.length > 0) {
            progressContainer.style.display = "block";
            progressBar.style.width = "0%";
            progressInfo.textContent = "0%";
          }

          // Connect to SSE before sending file
          connectSSE();

          log(`Preparing to send PKG to ${ipAddress}:${port}...`);
          techLog(`EXECUTE: Sending PKG to ${ipAddress}:${port}`, "info");

          try {
            // Send the file using FormData
            techLog(`Request: POST /upload (multipart/form-data)`, "info");
            const xhr = new XMLHttpRequest();

            xhr.upload.addEventListener("progress", function (e) {
              if (e.lengthComputable) {
                const percentComplete = (e.loaded / e.total) * 100;
                progressBar.style.width = percentComplete + "%";
                progressInfo.textContent = Math.round(percentComplete) + "%";
              }
            });

            xhr.onload = function () {
              if (xhr.status === 200) {
                const response = JSON.parse(xhr.responseText);
                if (response.success) {
                  resultDiv.innerHTML =
                    '<div class="success-box"><h3 class="success">Installation Started!</h3>' +
                    '<p class="success">' +
                    response.response +
                    "</p></div>";

                  // Clear form selections after successful submission
                  clearFormSelections();
                } else {
                  resultDiv.innerHTML =
                    '<div class="error-box"><h3 class="error">Installation Failed!</h3>' +
                    '<p class="error">' +
                    response.error +
                    "</p></div>";
                }
              } else {
                resultDiv.innerHTML =
                  '<div class="error-box"><h3 class="error">Error!</h3>' +
                  '<p class="error">Status: ' +
                  xhr.status +
                  "</p></div>";
              }
              progressContainer.style.display = "none";
            };

            xhr.onerror = function () {
              resultDiv.innerHTML =
                '<div class="error-box"><h3 class="error">Connection Error!</h3>' +
                '<p class="error">Failed to connect to the server.</p></div>';
              progressContainer.style.display = "none";
            };

            xhr.open("POST", "/upload");
            xhr.send(formData);
          } catch (error) {
            showStatus(`Error: ${error.message}`, "error");
            log(`❌ Connection error: ${error.message}`, "error");
            techLog(`Exception: ${error.message}`, "error");
          }
        });

        // Handle Clear Temporary Files button click
        document
          .getElementById("clear-tmp")
          .addEventListener("click", async function () {
            const ipAddress = ipAddressInput.value.trim();
            const port = parseInt(portInput.value.trim(), 10);
            const resultDiv = document.getElementById("pkg-result");

            // Validate form inputs
            if (!ipAddress) {
              showStatus("Please enter an IP address", "error");
              return;
            }

            if (isNaN(port) || port < 0 || port > 65535) {
              showStatus("Please enter a valid port number (0-65535)", "error");
              return;
            }

            log(`Clearing temporary files on ${ipAddress}:${port}...`);
            techLog(
              `EXECUTE: Clearing temporary files on ${ipAddress}:${port}`,
              "info"
            );

            try {
              // Send request to our server
              const response = await fetch("/clear-tmp", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  ipAddress: ipAddress,
                  port: port,
                }),
              });

              if (!response.ok) {
                throw new Error(`Server returned ${response.status}`);
              }

              const result = await response.json();

              if (result.success) {
                resultDiv.innerHTML = `<div class="success-box"><h3 class="success">Success!</h3><p class="success">${result.response}</p></div>`;
                log(`✅ ${result.response}`);
                techLog(`Response: ${result.response}`, "success");
              } else {
                resultDiv.innerHTML = `<div class="error-box"><h3 class="error">Error!</h3><p class="error">${result.response}</p></div>`;
                log(`❌ ${result.response}`, "error");
                techLog(`Error: ${result.response}`, "error");
              }
            } catch (error) {
              resultDiv.innerHTML = `<div class="error-box"><h3 class="error">Connection Error!</h3><p class="error">Failed to connect to the server: ${error.message}</p></div>`;
              log(`❌ Connection error: ${error.message}`, "error");
              techLog(`Exception: ${error.message}`, "error");
            }
          });

        // Initialize with a welcome message
        log("Remote Lua Loader initialized. Ready to send files.");
        techLog("Remote Lua Loader initialized. Ready to send files.", "info");

        // Handle LUA file upload (drag-and-drop and click)
        const luaUploadArea = document.getElementById("lua-upload-area");
        const luaFileInput = document.getElementById("luaFile");
        const luaFileInfo = document.getElementById("luaFileInfo");
        const luaFileName = document.getElementById("luaFileName");
        const luaFileSize = document.getElementById("luaFileSize");

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          luaUploadArea.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });
        ["dragenter", "dragover"].forEach((eventName) => {
          luaUploadArea.addEventListener(eventName, highlightLua, false);
        });
        ["dragleave", "drop"].forEach((eventName) => {
          luaUploadArea.addEventListener(eventName, unhighlightLua, false);
        });
        luaUploadArea.addEventListener("drop", handleLuaDrop, false);
        luaUploadArea.addEventListener("click", () => {
          luaFileInput.click();
        });
        luaFileInput.addEventListener("change", handleLuaFileSelect);

        function highlightLua(e) {
          luaUploadArea.classList.add("highlight");
        }
        function unhighlightLua(e) {
          luaUploadArea.classList.remove("highlight");
        }
        function handleLuaDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;
          handleLuaFiles(files);
        }
        function handleLuaFileSelect(e) {
          const files = e.target.files;
          handleLuaFiles(files);
        }
        function handleLuaFiles(files) {
          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith(".lua")) {
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(file);
              luaFileInput.files = dataTransfer.files;
              luaFileName.textContent = file.name;
              luaFileSize.textContent = formatFileSize(file.size);
              luaFileInfo.style.display = "block";
              luaUploadArea.classList.add("has-file");
            } else {
              showStatus("Please select a .lua file", "error");
              luaFileInput.value = "";
            }
          }
        }

        // Handle ELF file upload (drag-and-drop and click)
        const elfUploadArea = document.getElementById("elf-upload-area");
        const elfFileInput = document.getElementById("elfFile");
        const elfFileInfo = document.getElementById("elfFileInfo");
        const elfFileName = document.getElementById("elfFileName");
        const elfFileSize = document.getElementById("elfFileSize");

        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          elfUploadArea.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });
        ["dragenter", "dragover"].forEach((eventName) => {
          elfUploadArea.addEventListener(eventName, highlightElf, false);
        });
        ["dragleave", "drop"].forEach((eventName) => {
          elfUploadArea.addEventListener(eventName, unhighlightElf, false);
        });
        elfUploadArea.addEventListener("drop", handleElfDrop, false);
        elfUploadArea.addEventListener("click", () => {
          elfFileInput.click();
        });
        elfFileInput.addEventListener("change", handleElfFileSelect);

        function highlightElf(e) {
          elfUploadArea.classList.add("highlight");
        }
        function unhighlightElf(e) {
          elfUploadArea.classList.remove("highlight");
        }
        function handleElfDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;
          handleElfFiles(files);
        }
        function handleElfFileSelect(e) {
          const files = e.target.files;
          handleElfFiles(files);
        }
        function handleElfFiles(files) {
          if (files.length > 0) {
            const file = files[0];
            if (file.name.endsWith(".elf") || file.name.endsWith(".bin")) {
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(file);
              elfFileInput.files = dataTransfer.files;
              elfFileName.textContent = file.name;
              elfFileSize.textContent = formatFileSize(file.size);
              elfFileInfo.style.display = "block";
              elfUploadArea.classList.add("has-file");
            } else {
              showStatus("Please select a .elf or .bin file", "error");
              elfFileInput.value = "";
            }
          }
        }
      });

      // Subtle electrical spark animation
      (function () {
        const canvas = document.getElementById("spark-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        const sparks = [];
        const sparkColors = [
          "rgba(124,184,255,", // blue
          "rgba(0,255,255,", // cyan
          "rgba(255,255,255,", // white
          "rgba(80,180,255,", // electric blue
          "rgba(0,180,255,", // deep blue
        ];
        function spawnSpark(burst = false) {
          const x = Math.random() * width;
          const y = Math.random() * height * 0.8 + height * 0.1;
          const radius = burst ? 7 + Math.random() * 6 : 2 + Math.random() * 4;
          const maxAlpha = burst
            ? 0.7 + Math.random() * 0.2
            : 0.4 + Math.random() * 0.4;
          const color =
            sparkColors[Math.floor(Math.random() * sparkColors.length)];
          const duration = burst
            ? 900 + Math.random() * 600
            : 500 + Math.random() * 900;
          const shadow = burst ? 32 : 10 + Math.random() * 10;
          sparks.push({
            x,
            y,
            radius,
            alpha: 0,
            maxAlpha,
            t: 0,
            duration,
            color,
            shadow,
          });
        }
        function draw() {
          ctx.clearRect(0, 0, width, height);
          // Fade out old sparks
          for (let i = sparks.length - 1; i >= 0; i--) {
            const s = sparks[i];
            s.t += 16;
            // Fade in and out
            if (s.t < s.duration / 3) {
              s.alpha = s.maxAlpha * (s.t / (s.duration / 3));
            } else if (s.t > (s.duration * 2) / 3) {
              s.alpha =
                s.maxAlpha *
                (1 - (s.t - (s.duration * 2) / 3) / (s.duration / 3));
            } else {
              s.alpha = s.maxAlpha;
            }
            ctx.beginPath();
            ctx.arc(
              s.x,
              s.y,
              s.radius + Math.sin(s.t / 80) * 1.2,
              0,
              2 * Math.PI
            );
            ctx.shadowColor = s.color
              .replace("rgba(", "rgba(")
              .replace(",", ",1)");
            ctx.shadowBlur = s.shadow;
            ctx.fillStyle = s.color + s.alpha + ")";
            ctx.fill();
            ctx.shadowBlur = 0;
            if (s.t > s.duration) {
              sparks.splice(i, 1);
            }
          }
          // Occasionally spawn a new spark (increased frequency)
          if (Math.random() < 0.13) {
            spawnSpark();
          }
          // Rarely spawn a burst spark
          if (Math.random() < 0.012) {
            spawnSpark(true);
          }
          requestAnimationFrame(draw);
        }
        draw();
        window.addEventListener("resize", () => {
          width = window.innerWidth;
          height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
        });
      })();

      // Function to scan network
      async function scanNetwork() {
        const scanButton = document.getElementById("scanNetwork");
        const scanStatus = document.getElementById("scanStatus");
        const ps5Devices = document.getElementById("ps5Devices");
        const availableIPs = document.getElementById("availableIPs");
        const ipAddressInput = document.getElementById("ipAddress");

        // Reset state
        scanButton.disabled = true;
        scanButton.textContent = "Scanning...";
        scanStatus.className = "scan-status scanning";
        scanStatus.textContent = "Scanning network for PS5 devices...";
        scanStatus.style.display = "block";
        ps5Devices.style.display = "none";
        availableIPs.innerHTML = '<option value="">Select a PS5</option>';
        ipAddressInput.value = ""; // Clear the IP address input

        try {
          const response = await fetch("/scan-network");
          const data = await response.json();

          if (data.error) {
            scanStatus.className = "scan-status error";
            scanStatus.textContent = `Error: ${data.error}`;
            return;
          }

          if (data.activeHosts.length === 0) {
            scanStatus.className = "scan-status error";
            scanStatus.textContent = "No PS5 devices found on the network";
            return;
          }

          // Add PS5 devices to dropdown
          data.activeHosts.forEach((host) => {
            const option = document.createElement("option");
            option.value = host.ip;

            // Create port descriptions
            const portNames = {
              9026: "Remote Lua Loader",
              9021: "ELF Loader",
              1337: "FTP",
              9081: "Klog",
              12800: "DPIV2",
            };

            const portsText = host.ports
              .map((port) => {
                return `${port} (${portNames[port] || "Unknown"})`;
              })
              .join(", ");

            option.textContent = `PS5 (${host.ip}) - ${portsText}`;
            availableIPs.appendChild(option);
          });

          // Update scan status with port information
          const portCounts = {};
          data.activeHosts.forEach((host) => {
            host.ports.forEach((port) => {
              portCounts[port] = (portCounts[port] || 0) + 1;
            });
          });

          const portStatus = Object.entries(portCounts)
            .map(([port, count]) => {
              const portName =
                {
                  9026: "Remote Lua Loader",
                  9021: "ELF Loader",
                  1337: "FTP",
                  9081: "Klog",
                  12800: "DPIV2",
                }[port] || "Unknown";
              return `${count} with ${portName} (${port})`;
            })
            .join(", ");

          scanStatus.className = "scan-status success";
          scanStatus.textContent = `Found ${data.activeHosts.length} PS5(s) with advertised ports: ${portStatus}`;
          ps5Devices.style.display = "block";
        } catch (error) {
          console.error("Error scanning network:", error);
          scanStatus.className = "scan-status error";
          scanStatus.textContent = "Failed to scan network";
        } finally {
          // Reset button state
          scanButton.disabled = false;
          scanButton.textContent = "Scan Network";
        }
      }

      // Add event listeners
      document.addEventListener("DOMContentLoaded", () => {
        const scanButton = document.getElementById("scanNetwork");
        scanButton.addEventListener("click", scanNetwork);

        const availableIPs = document.getElementById("availableIPs");
        availableIPs.addEventListener("change", (e) => {
          const selectedIP = e.target.value;
          if (selectedIP) {
            document.getElementById("ipAddress").value = selectedIP;
          }
        });
      });

      // Function to handle scan results
      function handleScanResults(data) {
        const resultArea = document.getElementById("scanResult");
        const detailsArea = document.getElementById("detailsContent");
        const logArea = document.getElementById("logContent");

        if (data.error) {
          resultArea.textContent = `Error: ${data.error}`;
          log("Error scanning network: " + data.error, "error");
          return;
        }

        const localIPs = data.localIPs;
        const activeHosts = data.activeHosts;

        // Display local IPs
        let localIPsText = "Local IPs:\n";
        localIPs.forEach((ip) => {
          localIPsText += `- ${ip.interface}: ${ip.ip} (${ip.netmask})\n`;
        });

        // Display active PS5s with their ports
        let activeHostsText = "";
        if (activeHosts.length > 0) {
          activeHostsText = `Found ${activeHosts.length} PS5(s):\n`;
          activeHosts.forEach((host) => {
            const portsText = host.ports
              .map((port) => {
                const portNames = {
                  9026: "Remote Lua Loader",
                  9021: "ELF Loader",
                  1337: "FTP",
                  9081: "Klog",
                  12800: "DPIV2",
                };
                return `${port} (${portNames[port] || "Unknown"})`;
              })
              .join(", ");
            activeHostsText += `- ${host.ip} - Open ports: ${portsText}\n`;
          });
        } else {
          activeHostsText = "No PS5s found on the network.";
        }

        resultArea.textContent = localIPsText + "\n" + activeHostsText;

        // Log the results
        log("Network scan completed", "info");
        log(localIPsText, "info");
        log(activeHostsText, "info");
      }
    </script>
    <p id="bacedgod">
      Thank you,
      <a href="https://github.com/bacedgod" style="color: white">bacedgod</a>
    </p>
  </body>
</html>
